---
title: "Visualisation of transmission trees using epicontacts"
date: "`r Sys.Date()`"
output: 
    rmarkdown::html_vignette:
        toc: true
toc_depth: 4
vignette: >
    %\VignetteIndexEntry{visualise transmission trees}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r init, include=F}
library(knitr)
opts_chunk$set(message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE)
```

## Introduction

Visualising chains of transmission in an infectious disease outbreak can provide
a useful overview of the situation and help guide interventions. This vignette
illustrates how the `epicontacts` package can be used to create dynamic transmission 
chain visualisations like the one below:

```{r, echo = FALSE}
library(viridis)
library(ggplot2)
library(epicontacts)
## Simulate outbreak and return epicontacts object
sim_epicontacts <- function(R0 = 2, gentime_mu = 15, gentime_sd = 8) {

	## create generation time distribution
	param <- epitrix::gamma_mucv2shapescale(gentime_mu, gentime_sd/gentime_mu)
	dist <- distcrete::distcrete('gamma', 1, shape = param$shape, scale = param$scale)
	gentime <- dist$d(1:40)
	
	## simulate outbreak
	sim <- outbreaker::simOutbreak(R0 = R0, 
																 infec.curve = gentime, 
																 duration = 50,
																 n = 50,
																 rate.import.case = 0.2)
	
	## create anonymised case ID
	case_ID <- replicate(sim$n, paste0(sample(c(0:9, letters), 5, TRUE), collapse = ''))
	
	## create linelist with simulated metadata
	linelist <- data.frame(id = case_ID[sim$id],
	                       onset = as.Date(sim$onset, origin = "2012-07-02"),
	                       sex = sample(c("male", "female"), sim$n, TRUE),
	                       age = round(runif(sim$n, 0, 70), 1),
	                       outcome = sample(c("alive", "dead", "unknown"), sim$n, TRUE))
	
	contacts <- data.frame(from = case_ID[match(sim$ances, sim$id)], 
												 to = case_ID[sim$id])
	contacts$status <- sample(c("confirmed", "suspected"), nrow(contacts), TRUE)
	contacts$duration <- runif(nrow(contacts), 0, 20)
	## contact happened 0-10 days before start of symptom onset
	t_onset <- linelist$onset[match(contacts$to, linelist$id)]
	contacts$date <- t_onset - floor(runif(nrow(contacts), 0, 10))
	
	x <- make_epicontacts(linelist, contacts)

	return(x)
	
}

data(package = 'epicontacts')

plot(sim,
     type = 'ttree',
     x_axis = 'onset',
     ttree_shape = 'rectangle',
     root_order = 'size',
     node_order = 'onset',
     node_size = 'R_i',
     node_color = 'onset',
     edge_linetype = 'status',
     edge_color = 'duration',
     edge_flex = TRUE,
     position_unlinked = 'bottom',
     reverse_root_order = FALSE,
     reverse_node_order = TRUE,
     selector = FALSE,
     highlight_downstream = TRUE,
		 width = 800,
		 height = 900
     )

```

## Creating an epicontacts object

We begin with an `epicontacts` object, which consists of a linelist dataframe (specifying case IDs and any available case metadata) and a contacts dataframe (specifying pairs of IDs that have been in contact and any available properties of these contacts). For a detailed introduction to the `epicontacts` class, see the [overview vignette](epicontacts.html).

For this vignette, we will use a simulated outbreak as an example dataset. The linelist dataframe contains anonymised case IDs, dates
of symptom onset, age, sex and outcome for each case. The contacts dataframe specifies the infector and infectee in the `from` and `to` columns, respectively, as well as the contact status (suspected or confirmed), duration of contact and date of first contact. It is important to note that the current implementation can only accomodate a single infector per case.

Below is an overview of the outbreak data as an `epicontacts` object.

```{r, echo=FALSE}
sim
```


## Interactive transmission tree visualisation

We can then create a dynamic and interactive visualise of these transmission
chains using the `plot` function. We specify that we want to visualise our network
as a transmission tree using the `type` argument, and indicate which column in our 
linelist should be used for the x-axis (in this case, the date of symptom onset).

```{r}
plot(sim, type = 'ttree', x_axis = 'onset')
```

This is a dynamic visualisation with moveable nodes that provides additional node
information upon node hovering.

## Specifying node and edge attributes

Node color, node shape and node size can be mapped to a given column in the linelist 
using the `node_color`, `node_shape` and `node_size` arguments. Two additional node attributes
are calculated for each case that may be of interest, and can be also mapped. `R_i` is 
describes the individual reproductive number for each case (i.e. the number of infections 
caused by each case), and `size` is the total number of downstream cases (i.e the size of the
cluster with that case as an ancestor). For example:

```{r}
plot(sim, 
     type = 'ttree', 
     x_axis = 'onset',
     node_color = 'age',
     node_size = 'R_i',
     size_range = c(5, 20),
     selector = FALSE)
```

We can specify the size range of the nodes using the `size_range` argument. 

Edge color, width and linetype can be mapped to a given column in the contacts dataframe.
For example:

```{r}
plot(sim, 
     type = 'ttree', 
     x_axis = 'onset',
     node_color = 'age',
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_color = 'status',
     edge_linetype = 'status',
     edge_width = 'duration',
     selector = FALSE)
```

## Specifying transmission tree shape

There are two main shapes that the transmission tree can assume, specified using the `ttree_shape`
argument. The first is a `branching` shape as shown above, where a straight edge connects 
any two nodes. This is the most intuitive representation, however can result in overlapping edges
in a densely connected network. The second shape is `rectangle`, which produces a tree resembling
a phylogeny. For example:

```{r}
plot(sim, 
     type = 'ttree', 
     x_axis = 'onset',
     ttree_shape = 'rectangle',
     node_color = 'age',
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     selector = FALSE)
```

Furthermore, the vertical ordering of the nodes within the tree can be mapped to a given column
in the linelist dataframe using the `node_order` argument. This specifies the variable used to 
vertically order cases connected to the same infector. Similarly, the vertical ordering of the 
roots of each transmission chain (i.e. the index case of each chain) is specified using the 
`root_order` argument. The ordering can be reversed using the `reverse_node_order` and 
`reverse_root_order` arguments. Below is a tree with roots ordered by date of onset, 
(`root_order = "onset"`) and internal nodes ordered by downstream clust size (`node_order = "size"`).

```{r}
plot(sim, 
     type = 'ttree', 
     x_axis = 'onset',
     ttree_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'age',
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     selector = FALSE)
```

Each case node can be assigned a unique vertical position by toggling the `position_dodge` 
argument. The position of unconnected cases (i.e. with no reported contacts) is specified using the
`position_unlinked` argument. 

```{r}
plot(sim, 
     type = 'ttree', 
     x_axis = 'onset',
     ttree_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'age',
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     position_dodge = TRUE,
     position_unlinked = 'top',
     selector = FALSE)
```

## Additional options
Edges can curve upon manual adjustment of nodes, instead of remaining straight,
by toggling the `edge_flex` argument. All downstream cases of a given node can be
highlighted upon node selection using the `highlight_downstream` argument. 

```{r}
plot(sim, 
     type = 'ttree', 
     x_axis = 'onset',
     ttree_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'age',
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     edge_flex = TRUE,
     highlight_downstream = TRUE,
     selector = FALSE)
```

The `height` and `width` of the figure can be specified in pixels. 

```{r}
plot(sim, 
     type = 'ttree', 
     x_axis = 'onset',
     ttree_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'age',
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     height = 1000,
     selector = FALSE)
```

## Multiple infectors per case

The current algorithm was intended for visualising transmission trees with only a single
infector per case. As of now it can accomodate multiple infectors per case, however 
the clustering algorithm is not intended for this use case. It will attempt to place
roots that are linked by downstream cases in close proximity to each other, but this
is still a work in progres and works best with `ttree_shape = "branching"`. 

```{r, echo = FALSE}
set.seed(1)
to <- sample(sim$linelist$id, 5)
from <- sapply(match(to, sim$linelist$id), 
               function(i) sample(sim$linelist$id[sim$linelist$onset < sim$linelist$onset[i]], 1))

contact_2 <- data.frame(from = from, 
                        to = to,
                        status = sample(c("confirmed", "suspected"), 5, TRUE),
                        duration = runif(5, 0, 20),
                        date = sample(sim$linelist$onset, 5))

sim$contacts <- rbind(sim$contacts, contact_2)
```
```{r}
plot(sim, 
     type = 'ttree', 
     x_axis = 'onset',
     ttree_shape = 'branching',
     root_order = 'onset',
     node_order = 'size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'age',
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     height = 1000,
     position_dodge = FALSE,
     selector = FALSE)
```

## Outputting to ggplot

The same algorithm was implemented within ggplot. Most of the available options remain the same,
though check the documentation to be sure. The benefit of the ggplot output is that it allows
much more customisation by the user, as seen below in renaming the legend labels.

```{r, fig.width = 10, fig.height = 8}
plot(sim, 
     method = 'ggplot',
     x_axis = 'onset',
     ttree_shape = 'branching',
     root_order = 'onset',
     node_order = 'size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'age',
     node_size = 'R_i',
     size_range = c(3, 8),
     edge_linetype = 'status',
     position_dodge = FALSE) +
  labs(x = "Date of symptom onset",
       fill = 'Age of case',
       size = "# cases infected",
       linetype = "Contact status") +
  scale_x_date(breaks = "1 week", 
               date_labels = "%d-%b")
```