---
title: "Visualising timed transmission trees using epicontacts"
date: "`r Sys.Date()`"
output: 
    rmarkdown::html_vignette:
        toc: true
toc_depth: 4
vignette: >
    %\VignetteIndexEntry{visualise transmission trees}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r init, include=F}
library(knitr)
opts_chunk$set(message=FALSE, warning=FALSE, eval=TRUE, echo=TRUE)
```

## Introduction

Visualising chains of transmission in an infectious disease outbreak can provide
a useful overview of the situation and help guide interventions. This vignette
illustrates how the `epicontacts` package can be used to create interactive
transmission chain visualisations that display time on the x-axis, like the one
below. Hover over the nodes for more information, drag the nodes to move them
and click on them to highlight downstream cases.

```{r, echo = FALSE}
library(viridis)
library(ggplot2)
library(epicontacts)

data(package = 'epicontacts')
sim$directed <- TRUE
plot(sim,
     method = 'temporal',
     x_axis = 'onset',
     network_shape = 'rectangle',
     root_order = 'subtree_size',
     node_order = 'onset',
     node_size = 'R_i',
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     edge_linetype = 'status',
     edge_flex = FALSE,
     unlinked_pos = 'bottom',
     reverse_root_order = FALSE,
     reverse_node_order = TRUE,
     height = 700,
     width = 700,
     legend = TRUE,
     highlight_downstream = TRUE,
     axis_type = 'double'
     )

```

## Creating an epicontacts object

We begin with an `epicontacts` object, which consists of a linelist dataframe
(specifying case IDs and any available case metadata) and a contacts dataframe
(specifying pairs of IDs that have been in contact and any available properties
of these contacts). For a detailed introduction to the `epicontacts` class, see
the [overview vignette](epicontacts.html).

For this vignette, we will use a simulated outbreak as an example dataset. The
linelist dataframe contains anonymised case IDs, dates of symptom onset, age,
sex and outcome for each case. The contacts dataframe specifies the infector and
infectee in the `from` and `to` columns, as well as the contact status
(suspected or confirmed), location of contact (community or hospital), duration
of contact and date of first contact.

Below is an overview of the outbreak data as an `epicontacts` object.

```{r, echo=FALSE}
sim
```


## Basic plotting

We can then visualise these transmission chains using the `plot` function. We
specify that we want to visualise our network as a timed transmission tree using
the `method` argument, and indicate which column of the linelist should be used
for the x-axis (in this case, the date of symptom onset).

```{r}
plot(sim,
     method = 'temporal',
     x_axis = 'onset',
     height = 700,
     width = 700,
)
```

## Specifying node and edge attributes

Node color, node shape and node size can be mapped to a given column in the linelist 
using the `node_color`, `node_shape` and `node_size` arguments. Two additional node attributes
are calculated for each case that may be of interest, and can be also mapped. `R_i` is 
describes the individual reproductive number for each case (i.e. the number of infections 
caused by each case), and `subtree_size` is the total number of downstream cases (i.e the size of the
cluster with that case as an ancestor). For example:

```{r}
plot(sim, 
     method = 'temporal', 
     x_axis = 'onset',
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     height = 700,
     width = 700)
```

We can specify the size range of the nodes using the `size_range` argument, and
the color palette using the `col_pal` argument.

Edge color, width and linetype can be mapped to a given column in the contacts dataframe.
For example:

```{r}
plot(sim, 
     method = 'temporal', 
     x_axis = 'onset',
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_color = 'status',
     edge_linetype = 'status',
     edge_width = 'duration',
     height = 700,
     width = 700)
```

## Specifying transmission tree shape

There are two main shapes that the transmission tree can assume, specified using the `network_shape`
argument. The first is a `branching` shape as shown above, where a straight edge connects 
any two nodes. This is the most intuitive representation, however can result in overlapping edges
in a densely connected network. The second shape is `rectangle`, which produces a tree resembling
a phylogeny. For example:

```{r}
plot(sim, 
     method = 'temporal', 
     x_axis = 'onset',
     network_shape = 'rectangle',
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     height = 700,
     width = 700)
```

Furthermore, the vertical ordering of the nodes within the tree can be mapped to a given column
in the linelist dataframe using the `node_order` argument. This specifies the variable used to 
vertically order cases connected to the same infector. Similarly, the vertical ordering of the 
roots of each transmission chain (i.e. the index case of each chain) is specified using the 
`root_order` argument. The ordering can be reversed using the `reverse_node_order` and 
`reverse_root_order` arguments. Below is a tree with roots ordered by date of onset, 
(`root_order = "onset"`) and internal nodes ordered by subtree size (`node_order = "subtree_size"`).

```{r}
plot(sim, 
     method = 'temporal', 
     x_axis = 'onset',
     network_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'subtree_size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     height = 700,
     width = 700)
```

Each case node can be assigned a unique vertical position by toggling the
`position_dodge` argument. The position of unconnected cases (i.e. with no
reported contacts) is specified using the `unlinked_pos` argument.

```{r}
plot(sim, 
     method = 'temporal', 
     x_axis = 'onset',
     network_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'subtree_size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     position_dodge = TRUE,
     unlinked_pos = 'top',
     height = 700,
     width = 700)
```

The position of the parent node relative to the children nodes can be
specified using the `parent_pos` argument. The default option is to place the
parent node in the middle, however it can be placed at the bottom (`parent_pos =
'bottom'`) or at the top (`parent_pos = 'top'`).

```{r}
plot(sim, 
     method = 'temporal', 
     x_axis = 'onset',
     network_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'subtree_size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     position_dodge = FALSE,
     unlinked_pos = 'top',
     parent_pos = 'bottom',
     height = 700,
     width = 700)
```

Alternative tree layouts provided by `igraph` can also be used via the
`igraph_type` argument. This must be one of `rt`, `sugiyama` or `fr`. Your
mileage may vary with these layouts, are they are not specifically intended for
timed transmission trees. At times they may give a more space efficient layout,
though.

```{r}
plot(sim, 
     method = 'temporal', 
     x_axis = 'onset',
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     igraph_type = 'fr',
     height = 700,
     width = 700)
```

## Time axis
The number of dates axes can be specified using the `axis_type` argument. A
second axis can be added at the top of the plot by specifying `axis_type =
'double'` (`axis_type = 'none'` will remove the axes). The format of
the date labels can be specified using the `date_labels` argument, which uses
the standard codes defined in `strftime()`.

```{r}
plot(sim, 
     method = 'temporal', 
     x_axis = 'onset',
     network_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'subtree_size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     position_dodge = TRUE,
     unlinked_pos = 'top',
     axis_type = 'double',
     date_labels = "%b %d",
     height = 700,
     width = 700)
```

## Collapsing nodes
The option to collapse nodes up double-clicking them is toggled using the
`collapse` argument. Note that this currently only works properly for
`network_shape = 'branching'` due to a bug within `visNetwork`. Try double
clicking on a node below. 

```{r}
plot(sim, 
     method = 'temporal', 
     x_axis = 'onset',
     network_shape = 'branching',
     root_order = 'onset',
     node_order = 'subtree_size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     position_dodge = TRUE,
     unlinked_pos = 'top',
     axis_type = 'double',
     date_label = "%b %d",
     collapse = TRUE,
     height = 700,
     width = 700)
```

## Adding a title
A title can be added to the plot as follows:

```{r}
plot(sim, 
     method = 'temporal', 
     x_axis = 'onset',
     network_shape = 'branching',
     root_order = 'onset',
     node_order = 'subtree_size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     position_dodge = TRUE,
     unlinked_pos = 'top',
     axis_type = 'double',
     date_label = "%b %d",
     title = "Transmission chains, June-August 2018",
     collapse = TRUE,
     height = 700,
     width = 700)
```


## Additional options
Edges can curve upon manual adjustment of nodes, instead of remaining straight,
by toggling the `edge_flex` argument. All downstream cases of a given node can
be highlighted upon node selection using the `highlight_downstream`
argument. Node labels can be hidden using the `label` argument. This can
free up some space to label the edges using the `edge_label` argument. 

```{r}
plot(sim, 
     method = 'temporal', 
     x_axis = 'onset',
     network_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'subtree_size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     edge_label = 'status',
     edge_flex = TRUE,
     highlight_downstream = TRUE,
     label = FALSE,
     height = 700,
     width = 700)
```

The `height` and `width` of the figure can be specified in pixels. 

```{r}
plot(sim, 
     method = 'temporal', 
     x_axis = 'onset',
     network_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'subtree_size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     height = 700,
     width = 700)
```


## Identifying spurious contacts

The arguments `edge_color` and `edge_linetype` can be used to label contacts that seem spurious. In the example below, many of the contacts occur between cases with unrealistic serial intervals. To highlight these, we first specify a `max_si` and `min_si` and then create new columns in the `contacts` dataframe that indicate which contacts fall outside of this range. We use the `get_pairwise` function to calculate the difference in onset dates between contacts.

```{r, echo = FALSE}
set.seed(2)
sim_2 <- sim
sim_2$contacts$from <- sample(sim$contacts$from, replace = FALSE)
```

```{r, echo = TRUE}
max_si <- 30
min_si <- 3

si <- get_pairwise(sim_2, 'onset', function(x, y) y - x)
sim_2$contacts$suspicious <- si < min_si | si > max_si

plot(sim_2, 
     method = 'temporal', 
     x_axis = 'onset',
     network_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'subtree_size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_color = 'suspicious',
     title = "Uncleaned contact network",
     height = 700,
     width = 700,
     label = FALSE,
     thin = TRUE,
     position_dodge = TRUE)
```  

We can then remove these contacts and plot only those that seem feasible:

```{r, echo = TRUE}
sim_2_clean <- sim_2
sim_2_clean$contacts <- sim_2$contacts[!sim_2$contacts$suspicious,]
  
plot(sim_2_clean, 
     method = 'temporal', 
     x_axis = 'onset',
     network_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'subtree_size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'sex',
     col_pal = colorRampPalette(c("#427A82", "#AA6F39")),
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_color = 'suspicious',
     title = "Cleaned contact network",
     height = 700,
     width = 700,
     label = FALSE,
     thin = TRUE,
     position_dodge = TRUE)
```

## Multiple infectors per case and cyclical networks

The clustering algorithm can now handle multiple infectors per case, as well as cyclical networks. 
It will attempt to place roots that are linked by downstream cases in close proximity to each other, 
though this is still a work in progress. 

```{r, echo = FALSE}

set.seed(2)
to <- sample(sim$linelist$id, 5)
from <- sapply(match(to, sim$linelist$id),
               function(i) sample(sim$linelist$id[sim$linelist$onset < sim$linelist$onset[i]], 1))

contacts_3 <- data.frame(from = from, 
                        to = to,
                        status = sample(c("confirmed", "suspected"), 5, TRUE),
                        location = sample(c("community", "hospital"), 5, TRUE),
                        duration = runif(5, 0, 20),
                        date = sample(sim$linelist$onset, 5))

sim_3 <- sim
sim_3$contacts <- rbind(sim_3$contacts, contacts_3)
sim_3 $directed <- TRUE
col_pal <- colorRampPalette(c("#427A82", "#AA6F39"))
plot(sim_3, 
     method = 'temporal', 
     x_axis = 'onset',
     network_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'subtree_size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'sex',
     col_pal = col_pal,
     node_size = 'R_i',
     size_range = c(5, 20),
     edge_linetype = 'status',
     height = 700,
     width = 700,
     position_dodge = FALSE)
     
```  

## Outputting to ggplot

The same algorithm was implemented within ggplot. Most of the available options
remain the same, though check the documentation to be sure. The benefit of the
ggplot output is that it allows much more customisation by the user, as seen
below in renaming the legend labels, for example.

```{r, fig.width = 7, fig.height = 8}
sim_3$directed <- FALSE
plot(sim_3, 
     method = 'temporal',
     output = 'static',
     x_axis = 'onset',
     network_shape = 'rectangle',
     root_order = 'onset',
     node_order = 'subtree_size',
     reverse_node_order = FALSE,
     reverse_root_order = TRUE,
     node_color = 'sex',
     node_size = 'R_i',
     size_range = c(3, 8),
     edge_linetype = 'status',
     position_dodge = FALSE) +
  labs(x = "Date of symptom onset",
       fill = 'Age of case',
       size = "# cases infected",
       linetype = "Contact status") +
  scale_x_date(breaks = "1 week", 
               date_labels = "%d-%b")
```

