---
title: "Epicontacts: visualisation of network data in epidemiology"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
runtime: shiny
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---


<br>
Epicontacts package intends to facilitate the visualisation and analysis of any epidemiological data with an network component, such as contact tracing datasets and transmission chains.

Inputs data is built upon:

<bk>

 1. a **line list** (LL) of individuals. The line list contains a first column with unique identifier of individuals (record of cases and/or contacts) and any attributes in additionnal columns (e.g. age, sex, location, etc.).

<bk>

2. a **contact dataset** (CD) mapping the relationships between individuals. The contact dataset corresponds to the mapping of the relationships between individuals (edge between nodes). The contact dataset can contain any attributes qualifying this relationship (e.g.  exposure, serial interval, etc.).

<bk>

The package provides several network statistics,  functions to subset networks (by edge or two node) and visualize network in a various ways (2D, 3D, interactive graphics) using third-parties packages.

---------------------------------------
  
### Installation
  
To install the development version from github:
```{r install, eval=FALSE} 
  library("devtools")
  install_github("Hackout3/epicontacts")
```
  
The stable version can be installed from CRAN using: [*to be checked if needed*] _{package is not on CRAN yet, so prob not needed}_
```{r, eval=FALSE}
  # install.packages("epicontacts",force = TRUE) # ! Error: attempt to use zero-length variable name 
```

Then, to load the package, use:
```{r, eval=TRUE} 
  library("epicontacts")
```
  
### Content overview

Main features include:

* **epi_contacts**: a new S3 class for storing line list and contacts datasets.

* **igraph.epi_contacts**: creates an `igraph` object from a `epi_contacts` object.

* **clusters_epi_contacts**: assign clusters and corresponding cluster sizes to line list of an `epi_contacts` object (clusters being groups of connected individuals/nodes).

* **ebola.sim**: simulated Ebola outbreak dataset. 

* **get_degree**: number of contacts (edges)  per individuals (nodes) in a `epi_contacts` object.

* **get_id**:access unique IDs identifier(s) from `epi_contacts` object with various options.

* **get_pairwise**:  form an `epi_contacts` object, extract attributes of record(s) in contacts database using information provided in the line list database.

* **graph3D**: 3D graph from an `epi_contacts` object.

* **make_epi_contacts**: a constructor for the new `epi_contacts` class.

* **subset_clusters_by_id**: subset an `epi_contacts` object based on individuals/nodes of interest.

* **subset_clusters_by_size**:  subset an `epi_contacts` object based on size(s) of clusters (clusters being groups of connected individuals/nodes).

* **vis_epi_contacts**: plots epi_contacts objects using the visNetwork package.

* **epicontacts_server**: launches the epicontacts Shiny application on a local host

  
Other generic functions are proposed:

* **summary**: summary for  `epi_contacts` object.

* **plot**:  default plot for `epi_contacts` object using visNetwork package.

* **print**: default printing method for `epi_contacts` object.

* **x[i,j,contacts]**: susbset an `epi_contacts` object by retaining specified cases. [*to be checked if needed*]

<br>

Overview of package contents:

```{r Overv, eval=TRUE}
ls("package:epicontacts")
```

<br>
Load additionnal packages required for running examples below: 
loaded igraph, visNetwork

```{r lib, eval=TRUE}
  library("shiny")
```

<br>

### Visualisation and analysis

##### Load training dataset
  
A new S3 class `epi_contacts` for storing line list (LL)  and contacts dataset (CD) can be created from a line list (one row = one individual) and a contact dataset containing the relationship betwen individuals (one row = one edge). A training dataset `mers_kor_14` is used as running example (for more information, see` outbreaks` package  for dataset description).

```{r , eval=TRUE}
  str(mers_kor_14) # list of two dataframes: 1) line list and 2)contact dataset.
```

Dataframe corresponding to a line listing of individuals (= network nodes) which can be case(s) and/or contact(s) (if any), unique identifier and a set of descriptive variables.

```{r , eval=TRUE}
  colnames((mers_kor_14[[1]]))
```

Dataframe mapping relationship(s) between individuals (= network edges), unique identifiers and a set of descriptive variables.

```{r , eval=TRUE}
  colnames((mers_kor_14[[2]]))
```

<br>

### Create an `epi_contacts` object and get a summary

```{r, eval=TRUE}
  x <- make_epi_contacts(mers_kor_14[[1]],mers_kor_14[[2]], id="id", to="to", from="from",  directed=TRUE )    # create epi_contacts object as directed network
  summary(x)        # summary of epi_contacts object
```

<br>

#### Interactive visualization  (generic methods)

The default plot methods is using the "visNetwork" package to allow interactive visualization of network.

```{r, eval=FALSE}
  plot(x)  # generic method, equivalent to the following: vis_epi_contacts(x).
```

<br>

#### Selection functions by individuals

Access unique IDs identifier(s) from `epi_contacts` object with various options:

<br>

1. **Based on list of case (node)**

```{r, eval=TRUE}  
linelist_ids <- get_id(x, "linelist")   # linelist only ('linelist')
head(linelist_ids, n = 10)             # firt 10 records      
length(linelist_ids)                    # 162 unique records in line list

contacts_ids <- get_id(x, "contacts")   # contacts only ('contacts')
head(contacts_ids, n = 10)
length(get_id(x, "contacts"))           # 97 unique records in line list

all_ids <- get_id(x, "all")             # the union of both ('all')
head(all_ids, n = 10)
length(get_id(x, "all"))

common_ids <- get_id(x, "common")       # Intersection of both ('common')
head(common_ids, n = 10)
length(get_id(x, "common"))         
```

<br>

2. **Based on list of pairs (edge of the network)**
By default in a `epi_contacts` object, deg_in and deg_out returns the number of contacts/edges  per individuals/nodes. deg_in and deg_out requires a directed network.
[* ? to be tested with various direted and undirected network]

```{r, eval=TRUE}  
  deg_in   <- get_degree(x, "in")
  head(deg_in, n = 10)      
  table(deg_in)             # Distribution of incomning edge(s) by node
  
  deg_out   <- get_degree(x, "out")
  head(deg_out, n = 10)     
  table(deg_out)            # Distribution of outgoing edge(s)by node
  
  deg_both  <- get_degree(x, "both")
  head(deg_both, n = 10)    #  ID record with highest number of edges
  table(deg_both)           # Distribution of edge numbers  by nodes

```

<br>

#### Extract characteristics of pairwise nodes

The function allows pairwise processing of varaible in the line list according to each pairs in the contact dataset. For this example, date of onset of disease is extracted from the line list in order to compute the difference between disease date of onset date for each pairs (which corresponds to the **serial interval**).
[ ! add details of the default settings, behavior for date, string, numeric]

<br>

1. **By a date in the line list**

```{r, eval=TRUE} 
SI <- get_pairwise(x, "dt_onset")   
summary(SI)

```
<br>

Distribution of the serial interval:

```{r, eval = TRUE}
renderPlot({
    hist(SI, col="grey", border="white", xlab="Days after symptoms",
     main="MERS Korea 2014 - Serial Interval")
    })  
```
<br><br>

2. **By a categorical variable (sex in the example below) and applying a specfic function (e.g. table)**

```{r, eval=TRUE} 
get_pairwise(x, "sex", f=table) # allow the use of a custom function
fisher.test(get_pairwise(x, "sex", f=table)) 
```

<br>

#### Incorporate cluster IDs and sizes into the line list
The function `clusters_epi_contacts` adds a unique cluster identifier to the line list as a column named `cluster_member`. It also adds another column, `cluster_size`, corresponding to the size of the cluster. 
_Note: kn this context,a  'cluster'  corresponds to groups of connected individuals (or connected components)._

```{r, eval=TRUE, message=FALSE} 
x_id <- clusters_epi_contacts(x)    # adds two columns, one with cluster IDs and other with cluster sizes
table(x_id$linelist$cluster_size,x_id$linelist$cluster_member) # one cluster of 94 obersvations connected together with at least one edge, one cluster of 3 observations  and 65 single observations.
```

<br>

##### Subsetting clusters in `epi_contacts` object by individual IDs or cluster size

1. **Subset network via  node-based selection** 

```{r, eval=TRUE}   
  nodes <- c("SK_14","SK_145")                    # select  one or more record(s)
  x_subset_N <- subset_clusters_by_id(x, nodes)   # subset connected components including the proposed ID
  plot(x_subset_N)                              
```
  
2. **Subset network via cluster size** 
  
```{r, eval=TRUE}   
  x_subset_S1 <- subset_clusters_by_size(x, cs = 3) # to be updated
  plot(x_subset_S1)
  x_subset_S2 <- subset_clusters_by_size(x, cs_min = 10, cs_max = 100)
  plot(x_subset_S2)
  
```

<br>

#### Network representation with static 2D representation 


```{r, eval=FALSE}
  devtools::install_github("briatte/ggnetwork") # Geoms to plot networks with ggplot2  
```


The current example is built is using ggnetwork package

```{r, eval=TRUE}  
  
  library("igraph") 

  net_igraph  <-  igraph.epi_contacts(x)      # Conversion in i-graph object
  l <- layout.reingold.tilford(net_igraph)    # Tree-like graph using the Reingold-Tilford graph layout algorithm (alternative l <- layout.reingold.tilford(net_igraph, circular=T))
      plot(net_igraph,
             ### NODES   
             vertex.color= "red" ,                                                        vertex.frame.color= "white",                              
             vertex.shape= "circle",                                    
             vertex.size=  2.5,                                           #	 size of the node (default is 15) or V(net)$size
             # vertex.size2=      ,                                       #	 the second size of the node (e.g. for a rectangle)
             vertex.label= NA  ,                                          #	 character vector used to label the nodes to remove vertex.label=NA   V(net)$name_vtx
              ### EDGES	 
             edge.color=  E(net_igraph)$color,                            # edge color "grey70"
             edge.width= 0.5 ,                                            # edge width, defaults to 1 # (1/E(net)$ser_int)*30
             edge.arrow.size=  0.1 ,                                      # arrow size, defaults to 1
             edge.arrow.width=  0.25  ,                                   # arrow width, defaults to 1
             margin= 0 ,                                                  # empty space margins around the plot, vector with length 4
             frame=  TRUE,                                                # if TRUE, the plot will be framed
             main= list(paste("R igraph package",sep=""), cex = 1, col = "black", font = 3),     # if set, adds a title to the plot
            layout=l                                                    # layout choosen above  
        ) 
```
  
The current example is built is using ggnetwork package # how ad render graph ? Nistara

```{r, eval=TRUE}

  library("ggplot2")
  library("ggnetwork")
  library("intergraph")

  net_igraph  <-  igraph.epi_contacts(x_subset_N)
  net_ggnet <- asNetwork(net_igraph) # For more information on conversion process
  head(ggnetwork(net_ggnet))  # ggnetwork() fucntion insure conversion in dataframe for further used in ggplot2
  tail(ggnetwork(net_ggnet))
  
   ggplot( ggnetwork(net_ggnet, layout = "fruchtermanreingold", arrow.gap = 0.01),
      aes(x, y, xend = xend, yend = yend)) +
      geom_edgetext(aes(label = diff_dt_onset ), label.size = NA, color = "grey10", fill = "white",size= 2.5, fontface = "bold") +
      geom_edges(aes(linetype = "solid"), size = 0.5, color= "grey60", alpha=0.7, arrow = arrow(angle= 40, length = unit(3, "pt"), type = "closed")) +
      geom_nodes(aes(), color = "goldenrod3", size=4, alpha=0.5) +
      theme_blank( legend.position="none")
  
 

```

<br>
 
#### Network representation with 3D representation

```{r, eval=TRUE}
library(threejs)

x_subset <- subset_clusters_by_size(x, cs_min = 50, cs_max = 100)
g <- graph3D(x_subset, v_col_by = "sex")

renderGraph(g)

```
To interact with the plot:

* zoom: scrollwheel
* rotate: left-mouse button + move
* pan: right-mouse button + move
* identify node by label: mouse over 

For more information on 3D javascript graphs, visit B.W. Lewis' [page](http://bwlewis.github.io/rthreejs/graphjs.html)

<br>

#### To be completed --> Run epicontacts package as a app.
Run contacts package as local host epicontacts_server  --> Fonction export to be developped   ? saving image of current view in various formats. 
  
The functionalities of Contacts are also available via a user-friendly web interface,    running locally on the default web browser.   It can be started by simply typing ContactsServer(). The interface allows you to import both dataset required  epicontact object  (line list  and contacts data) and explore interactively network.


####  [* ? To be completed if needed  ? Thibaut]
The `epi_contacts` object can be subsetted in different manner using specific conditions    x[i,j,contacts]

